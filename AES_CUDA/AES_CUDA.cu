
#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <cmath>
#include "AES_CUDA.h"
#include "key_expansion.h"
#include "CPU_AES.h"

__device__ BYTE gSBOX[256] = {
 0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16 };

BYTE SBOX[256] = {
 0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16 };

BYTE RCON[256] = {
0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d };


__host__ __device__ BYTE xtimes(BYTE x) {
    return ((x << 1) ^ (((x >> 7) & 1) * 0x1b));
}


struct gword {
    BYTE byte[4];
    __host__ __device__ gword operator^(gword x) {
        gword z;
        z.byte[0] = x.byte[0] ^ this->byte[0];
        z.byte[1] = x.byte[1] ^ this->byte[1];
        z.byte[2] = x.byte[2] ^ this->byte[2];
        z.byte[3] = x.byte[3] ^ this->byte[3];
        return z;
    }
};

struct gblock_t {
    gword gstate[4] = {};
    __host__ __device__ gblock_t operator^(gblock_t x) {
        gblock_t z;
        z.gstate[0] = x.gstate[0] ^ this->gstate[0];
        z.gstate[1] = x.gstate[1] ^ this->gstate[1];
        z.gstate[2] = x.gstate[2] ^ this->gstate[2];
        z.gstate[3] = x.gstate[3] ^ this->gstate[3];
        return z;
    }
};

__device__ void gpu_mix_columns(gblock_t* block) {
    gblock_t out;

    for (int i = 0; i < BLOCKSIZE; i += 4) {
        out.gstate->byte[i + 0] = xtimes(block->gstate->byte[i + 0]) ^ xtimes(block->gstate->byte[i + 1]) ^ block->gstate->byte[i + 1] ^ block->gstate->byte[i + 2] ^ block->gstate->byte[i + 3];
        out.gstate->byte[i + 1] = block->gstate->byte[i + 0] ^ xtimes(block->gstate->byte[i + 1]) ^ xtimes(block->gstate->byte[i + 2]) ^ block->gstate->byte[i + 2] ^ block->gstate->byte[i + 3];
        out.gstate->byte[i + 2] = block->gstate->byte[i + 0] ^ block->gstate->byte[i + 1] ^ xtimes(block->gstate->byte[i + 2]) ^ xtimes(block->gstate->byte[i + 3]) ^ block->gstate->byte[i + 3];
        out.gstate->byte[i + 3] = xtimes(block->gstate->byte[i + 0]) ^ block->gstate->byte[i + 0] ^ block->gstate->byte[i + 1] ^ block->gstate->byte[i + 2] ^ xtimes(block->gstate->byte[i + 3]);
    }

    *block = out;
}

__device__ void gpu_shift_rows(gblock_t* block) {  // Performs shift rows operation on a block
    gblock_t out;
    //On per-row basis (+1 shift X each row)
    //Row 1
    out.gstate->byte[0] = block->gstate->byte[0];
    out.gstate->byte[4] = block->gstate->byte[4];
    out.gstate->byte[8] = block->gstate->byte[8];
    out.gstate->byte[12] = block->gstate->byte[12];
    //Row 2
    out.gstate->byte[1] = block->gstate->byte[5];
    out.gstate->byte[5] = block->gstate->byte[9];
    out.gstate->byte[9] = block->gstate->byte[13];
    out.gstate->byte[13] = block->gstate->byte[1];
    //Row 3
    out.gstate->byte[2] = block->gstate->byte[10];
    out.gstate->byte[6] = block->gstate->byte[14];
    out.gstate->byte[10] = block->gstate->byte[2];
    out.gstate->byte[14] = block->gstate->byte[6];
    //Row 4
    out.gstate->byte[3] = block->gstate->byte[15];
    out.gstate->byte[7] = block->gstate->byte[3];
    out.gstate->byte[11] = block->gstate->byte[7];
    out.gstate->byte[15] = block->gstate->byte[11];

    *block = out;
}

__device__ void gpu_sbox_substitute(gblock_t* block) { //Performs an S-box substitution on a block
    
    for (int i = 0; i < 16; i++) {
        block->gstate->byte[i] = gSBOX[block->gstate->byte[i]];
    }
}

__device__ void gpu_addroundkey(gblock_t* block, gblock_t* expandedkeys) {
    *block = *block ^ *expandedkeys;
}

__global__ void aes_kernal(gblock_t* block, gblock_t* expandedkeys) {
    unsigned int i = threadIdx.x;
    gpu_addroundkey((block+i), expandedkeys);
    for (int round=1; round < Nr; round++) {
        gpu_sbox_substitute((block + i));
        gpu_shift_rows((block + i));
        gpu_mix_columns((block + i));
        gpu_addroundkey((block + i), (expandedkeys + round));
    }
    gpu_sbox_substitute((block + i));
    gpu_shift_rows((block + i));
    gpu_addroundkey((block + i), (expandedkeys + Nr));
    
}


int main()
{
    block_t* key = (block_t*)malloc(sizeof(block_t));                           // storage for key    
    if (key == NULL) { printf("error key allocation"); return -1; } 
    block_t* textfile = (block_t*)malloc(sizeof(block_t));              
    if (textfile == NULL) { printf("error text allocation"); return -1; }       // storage for inputfile
    word* expandedkeys = (word*)malloc(sizeof(word) * (Nb * (Nr + 1))); 
    if (expandedkeys == NULL) { printf("error text allocation"); return -1; }   // storage for expanded key - 44 words
    
    
    FILE* pKeyFile = fopen("./key.txt", "rb");                          
    if (pKeyFile == NULL) { printf("error opening key file"); return -1; }
    FILE* pInFile = fopen("./text.txt", "rb");                          
    if (pKeyFile == NULL) { printf("error opening input file"); return -1; }

    fseek(pInFile, 0, SEEK_END);
    float file_len = ftell(pInFile);
    rewind(pInFile);
    int NumofBlocks = ceil(file_len / BLOCKSIZE);
    block_t* textblocks = (block_t*)calloc(NumofBlocks, sizeof(block_t));
    block_t* encryptedtext = (block_t*)calloc(NumofBlocks, sizeof(block_t));
    if (textblocks == NULL) { printf("error allocation textblocks"); return -1; }

    for (BYTE i = 0; i < 16; i++) {
        int ret = fscanf(pKeyFile, "%hhx", &key->state->byte[i]); //Read the private key in -  fscanf reads files and saves space sperated hex values to a local memory
    }

    for (BYTE i = 0; i < 32; i++) {
        int ret = fscanf(pInFile, "%hhx", &textblocks->state->byte[i]); //Read the private key in -  fscanf reads files and saves space sperated hex values to a local memory
    }
    //fread(textblocks, sizeof(BYTE), file_len, pInFile);

    key_expansion(key, (block_t*)expandedkeys);

    gblock_t* d_textblocks;
    gblock_t* d_expandedkeys;
    cudaMalloc(&d_textblocks,(sizeof(block_t)*NumofBlocks));
    cudaMalloc(&d_expandedkeys, (sizeof(block_t) * NUMOFKEYS));

    //cpu_cipher_text(textblocks, (block_t*)expandedkeys, NumofBlocks);
   
    cudaMemcpy(d_textblocks, textblocks, (sizeof(block_t) * NumofBlocks), cudaMemcpyHostToDevice);
    cudaMemcpy(d_expandedkeys, expandedkeys, (sizeof(block_t) * NUMOFKEYS), cudaMemcpyHostToDevice);

    aes_kernal <<<1, 4 >>> (d_textblocks, d_expandedkeys); // A round key for single block --  later used for cuda
    cudaMemcpy(textblocks, d_textblocks, (sizeof(block_t) * NumofBlocks), cudaMemcpyDeviceToHost);
    






};